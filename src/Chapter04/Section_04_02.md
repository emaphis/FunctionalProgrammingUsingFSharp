# 4.2 Construction and decomposition of lists

## The $cons$ operator

The infix operator $::$ called "cons" builds lists from its head and its tail and adds an element to the front of a list.

```fsharp
> let x = 2::[3;4;5];;
val x: int list = [2; 3; 4; 5]

> let y = "" :: [];;
val y: string list = [""]
```

The operator `associates` to the right so $x::x_1::xs$ means $x_0::(x_1::xs)$ where $x_0$ and $x_1$ have the same type and $xs$ is a list of that type.

```fsharp
> let z = 2::3::[4;5];;
val z: int list = [2; 3; 4; 5]
```

## List patterns
While the cons operator can be used to construct a list from a `head` and a `tail` list,
the `cons` operator can also be used in `list patterns` and pattern matching.  List patterns can also be used to define function on lists.

The list pattern `[]` is an empty list while non-empty lists are constructed using the `cons` operator $x::xs$ matches a non-empty list.

The $[\space]$ operator matches only an empty list while $x::xs$ matches any non-empty list $[x_0;x_1;\dots;x_{n-1}]$ matching $x \mapsto x_0$ and $xs \mapsto [x_1; \dots; x_{n-1}]$

For example

```fsharp
>  let x::xs = [1;2;3];;
val xs: int list = [2; 3]
val x: int = 1
```

will bind $x$ to the value $1$ and $xs$ to the value $[2;3]$ by matching the value $[1;2;3]$ to the pattern $x::xs$.

The execution of the declarations:

```fsharp
> let x::xs = [1;2;3];;
val xs: int list = [2; 3]
val x: int = 1
```

Will simultaneously bind $x$ to $1$ and $xs$ to $[2;3]$

A list pattern to match a fixe number of elements, i.e. a three element list is written $x0::x1::x2::[]$ of shorter $[x0;x1;x3]$.

```fsharp
>  let [x0;x1;x2] = [(1,true); (2,false); (3, false)];;
val x2: int * bool = (3, false)
val x1: int * bool = (2, false)
val x0: int * bool = (1, true)
```

We can construct list patterns that match lists with two or more elements (e.g., $x0::x1::xs$ ), and
 list patterns matching only non-empty lists of pairs (e.g., $(y1,y2)::ys$ ):

 ```fsharp
>  let x0::x1::xs = [1.1; 2.2; 3.3; 4.4; 5.5];;
val xs: float list = [3.3; 4.4; 5.5]
val x1: float = 2.2
val x0: float = 1.1

>  let (y1, y2)::ys = [(1,[1]); (2, [2]); (3, [3]); (4,[4])];;
val ys: (int * int list) list = [(2, [2]); (3, [3]); (4, [4])]
val y2: int list = [1]
val y1: int = 1
 ```

## Simple list expressions

F# has special constructs that can generate lists. In this case, `range expressions`.

$$ [ b .. e ] \quad [ b .. s .. e ]$$

where $b, e$ and $s$ have number types.

The range expression $[b .. e]$ where $e \geq b$ generates the list of consecutive elements::

$$[b; b+1;b+2; ..; b+n]$$

where $n$ is chosen such that $b+n \leq e \lt b+n+1$

For example the list of integers from $-3 to 5$ is generated by:

```fsharp
>  [-3 .. 5 ];;
val it: int list = [-3; -2; -1; 0; 1; 2; 3; 4; 5]
```

or a list of floats

```fsharp
> [2.4 .. 3.0 ** 1.7];;
val it: float list = [2.4; 3.4; 4.4; 5.4; 6.4]
``

Note that:

```fsharp
> 3.0 ** 1.7;;
val it: float = 6.47300784
```

The expression $s$ in the expression $[b..s..e]$ is called the step. It can be positive or negative, but not zero:

$$
[b \space ..\space s \space ..\space e] = [b;b+s; b+2s; \space ..;b+ns] \\
\space where \space
\begin{cases}
  \space b+ns \leq e \lt b + (n+1)s \space\text(if ) s \space \text( is \space positive) \\
  \space b+ns \geq e \gt b + (n+1)s \space\text(if ) s \space \text( is \space negative)
\end{cases}
$$

A descending list of integers from $6$ to $2$ is generated by:

```fsharp
> [6 .. -1 .. 2];;
val it: int list = [6; 5; 4; 3; 2]
```

and the float list consisting of $0, \pi / 2, \pi, 3/4 \pi, 2\pi$

```fsharp
> [0.0 .. System.Math.PI/2.0 .. 2.0*System.Math.PI];;
val it: float list = [0.0; 1.570796327; 3.141592654; 4.71238898; 6.283185307]
```

An exception is raised if the step is $0$.

```fsharp
  [0 .. 0 .. 0];;
System.ArgumentException: The step of a range cannot be zero. (Parameter 'step')
```
